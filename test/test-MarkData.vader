################################################################################
# TrimMarksHeader tests
################################################################################

Execute (Empty Mark String):
  let g:markstring = 'mark line  col file/text'
  let g:result = markbar#helpers#TrimMarksHeader(g:markstring)
Then:
  AssertEqual '', g:result

Execute (LF-Terminated Empty Mark String):
  let g:markstring = "mark line  col file/text\n"
  let g:result = markbar#helpers#TrimMarksHeader(g:markstring)
Then:
  AssertEqual '', g:result

Execute (CRLF-Terminated Empty Mark String):
  let g:markstring = "mark line  col file/text\r\n"
  let g:result = markbar#helpers#TrimMarksHeader(g:markstring)
Then:
  AssertEqual '', g:result

Execute (Leading Whitespace Mark String):
  let g:markstring = "
    \  \n \n \n mark line  col file/text\n
    \ A     97    0 ~/plugin/vim-markbar/plugin/vim-markbar.vim\n
  \ "
  let g:result = markbar#helpers#TrimMarksHeader(g:markstring)
Then:
  let g:expected = "
    \ A     97    0 ~/plugin/vim-markbar/plugin/vim-markbar.vim\n
  \ "
  AssertEqual g:expected, g:result

Execute (Single Item Mark String):
  let g:markstring = "
    \ mark line  col file/text\n
    \ A     97    0 ~/plugin/vim-markbar/plugin/vim-markbar.vim\n
  \ "
  let g:result = markbar#helpers#TrimMarksHeader(g:markstring)
Then:
  let g:expected = "
    \ A     97    0 ~/plugin/vim-markbar/plugin/vim-markbar.vim\n
  \ "
  AssertEqual g:expected, g:result

Execute (CRLF-Terminated Single Item Mark String):
  let g:markstring = "
    \ mark line  col file/text\n
    \ A     97    0 ~/plugin/vim-markbar/plugin/vim-markbar.vim\r\n
  \ "
  let g:result = markbar#helpers#TrimMarksHeader(g:markstring)
Then:
  let g:expected = "
    \ A     97    0 ~/plugin/vim-markbar/plugin/vim-markbar.vim\r\n
  \ "
  AssertEqual g:expected, g:result

Execute (Two Item Mark String):
  let g:markstring = "
    \ mark line  col file/text\n
    \ A     97    0 ~/plugin/vim-markbar/plugin/vim-markbar.vim\n
    \ ]     24    0 Then:\n
  \ "
  let g:result = markbar#helpers#TrimMarksHeader(g:markstring)
Then:
  let g:expected = "
    \ A     97    0 ~/plugin/vim-markbar/plugin/vim-markbar.vim\n
    \ ]     24    0 Then:\n
  \ "
  AssertEqual g:expected, g:result

Execute (Three Item Mark String):
  let g:markstring = "
    \ mark line  col file/text\n
    \ A     97    0 ~/plugin/vim-markbar/plugin/vim-markbar.vim\n
    \ ]     24    0 Then:\n
    \ .     23    0\n
  \ "
  let g:result = markbar#helpers#TrimMarksHeader(g:markstring)
Then:
  let g:expected = "
    \ A     97    0 ~/plugin/vim-markbar/plugin/vim-markbar.vim\n
    \ ]     24    0 Then:\n
    \ .     23    0\n
  \ "
  AssertEqual g:expected, g:result

Execute (Multiitem Mark String):
  let g:markstring = "
    \ mark line  col file/text\n
    \ A     97    0 ~/plugin/vim-markbar/plugin/vim-markbar.vim\n
    \ [      1    0 The quick brown fox jumps over the lazy dog\n
    \ ]     24    0 Then:\n
    \ ^     23    2\n
    \ .     23    0\n
  \ "
  let g:result = markbar#helpers#TrimMarksHeader(g:markstring)
Then:
  let g:expected = "
    \ A     97    0 ~/plugin/vim-markbar/plugin/vim-markbar.vim\n
    \ [      1    0 The quick brown fox jumps over the lazy dog\n
    \ ]     24    0 Then:\n
    \ ^     23    2\n
    \ .     23    0\n
  \ "
  AssertEqual g:expected, g:result

Execute (CRLF-Terminated Multiitem Mark String):
  let g:markstring = "
    \ mark line  col file/text\r\n
    \ A     97    0 ~/plugin/vim-markbar/plugin/vim-markbar.vim\r\n
    \ [      1    0 The quick brown fox jumps over the lazy dog\r\n
    \ ]     24    0 Then:\r\n
    \ ^     23    2\r\n
    \ .     23    0\r\n
  \ "
  let g:result = markbar#helpers#TrimMarksHeader(g:markstring)
Then:
  let g:expected = "
    \ A     97    0 ~/plugin/vim-markbar/plugin/vim-markbar.vim\r\n
    \ [      1    0 The quick brown fox jumps over the lazy dog\r\n
    \ ]     24    0 Then:\r\n
    \ ^     23    2\r\n
    \ .     23    0\r\n
  \ "
  AssertEqual g:expected, g:result

Execute (Error-Check Already Trimmed):
  let g:markstring = "
    \ A     97    0 ~/plugin/vim-markbar/plugin/vim-markbar.vim\r\n
    \ [      1    0 The quick brown fox jumps over the lazy dog\r\n
    \ ]     24    0 Then:\r\n
    \ ^     23    2\r\n
    \ .     23    0\r\n
  \ "
Then:
  AssertThrows markbar#helpers#TrimMarksHeader(g:markstring)

Execute (Error-Check Already Trimmed Edge Case):
  let g:markstring = "
    \ [      1    0 The quick brown fox jumps over the lazy dog\r\n
    \ ]     24    0 Then:\r\n
    \ ^     23    2\r\n
    \ a     97    0 mark line  col file/text\r\n
    \ .     23    0\r\n
  \ "
Then:
  AssertThrows markbar#helpers#TrimMarksHeader(g:markstring)


################################################################################
# MarkData tests
################################################################################

Execute (MarkData: Local Mark):
  let g:markstring = "
    \ a     97    0 mark line  col file/text\r\n
  \ "
  let g:result = markbar#MarkData#New(g:markstring, 'foobar.txt',
                                    \ '/foo/bar/foobar.txt')
Then:
  AssertEqual 'MarkData', g:result['TYPE']
  AssertEqual 'a',  g:result.getMarkChar()
  AssertEqual '97', g:result.getLineNo()
  AssertEqual '0',  g:result.getColumnNo()
  Assert           !g:result.isGlobal()

Execute (MarkData: Non-Alphabetic Mark):
  let g:markstring = "
    \ [      1    0 The quick brown fox jumps over the lazy dog\n
  \ "
  let g:result = markbar#MarkData#New(g:markstring, 'foobar.txt',
                                    \ '/foo/bar/foobar.txt')
Then:
  AssertEqual 'MarkData', g:result['TYPE']
  AssertEqual '[', g:result.getMarkChar()
  AssertEqual '1', g:result.getLineNo()
  AssertEqual '0', g:result.getColumnNo()
  Assert          !g:result.isGlobal()

Execute (MarkData: Construct from 'Synthetic' Markstring):
  normal! i12345
  normal! viwy
  let left_bracket =
    \ markbar#MarkData#New(markbar#helpers#MakeMarkString('['), 'foobar.txt',
                         \ '/foo/bar/foobar.txt')
  let right_bracket =
    \ markbar#MarkData#New(markbar#helpers#MakeMarkString(']'), 'foobar.txt',
                         \ '/foo/bar/foobar.txt')
Then:
  AssertEqual 'MarkData', g:result['TYPE']
  AssertEqual '[',  left_bracket.getMarkChar()
  AssertEqual '1',  left_bracket.getLineNo()
  AssertEqual '1',  left_bracket.getColumnNo()
  Assert           !left_bracket.isGlobal()

  AssertEqual 'MarkData', g:result['TYPE']
  AssertEqual ']',  right_bracket.getMarkChar()
  AssertEqual '1',  right_bracket.getLineNo()
  AssertEqual '5',  right_bracket.getColumnNo()
  Assert           !right_bracket.isGlobal()

Execute (MarkData: Global File Mark):
  let g:markstring = "
    \ D      64    31 The quick brown fox jumps over the lazy dog\r\n
  \ "
  let g:result = markbar#MarkData#New(g:markstring, 'foobar.txt',
                                    \ '/foo/bar/foobar.txt')
Then:
  AssertEqual 'MarkData', g:result['TYPE']
  AssertEqual 'D',  g:result.getMarkChar()
  AssertEqual '64', g:result.getLineNo()
  AssertEqual '31', g:result.getColumnNo()
  Assert            g:result.isGlobal()

Execute (MarkData: ShaDa Numeric Mark):
  let g:markstring = "
    \ 8      19   5 The quick brown fox jumps over the lazy dog\n
  \ "
  let g:result = markbar#MarkData#New(g:markstring, 'foobar.txt',
                                    \ '/foo/bar/foobar.txt')
Then:
  AssertEqual 'MarkData', g:result['TYPE']
  AssertEqual '8',  g:result.getMarkChar()
  AssertEqual '19', g:result.getLineNo()
  AssertEqual '5',  g:result.getColumnNo()
  Assert            g:result.isGlobal()

Execute (MarkData: Error Check, Invalid Markstring):
  let g:markstring = "
    \ D      1  The quick brown fox jumps over the lazy dog\r\n
  \ "
Then:
  AssertThrows markbar#MarkData#New(g:markstring, 'foobar.txt',
                                    \ '/foo/bar/foobar.txt')

Execute (MarkData gives proper names to "punctuation marks"):
  let g:marks_and_names = [
    \ ["'", 'Last Jump'],
    \ ['<', 'Selection Start'],
    \ ['>', 'Selection End'],
    \ ['"', 'Left Buffer'],
    \ ['^', 'Left Insert Mode'],
    \ ['.', 'Last Change'],
    \ ['[', 'Change/Yank Start'],
    \ [']', 'Change/Yank End'],
    \ ['(', 'Sentence Start'],
    \ [')', 'Sentence End'],
    \ ['{', 'Paragraph Start'],
    \ ['}', 'Paragraph End'],
  \ ]
  for [g:mark, g:name] in g:marks_and_names
    let g:markdata = markbar#MarkData#New(printf('%s 1 2 foobar', g:mark),
        \ 'foobar.txt', '/foo/bar/foobar.txt')
    AssertEqual g:name, g:markdata.getDefaultName()
  endfor
