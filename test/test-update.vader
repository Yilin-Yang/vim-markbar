Execute (Delete All Marks, Open Buffers):
  " let s:marks = '
  "   \ ABCDEFGHIJKLMNOPQRSTUVWXYZ
  "   \ abcdefghijklmnopqrstuvwxyz
  "   \ 0123456789
  "   \ <>"^.
  " \ '

  " Delete all preexisting marks.
  delmarks a-zA-Z0-9<>\"^.

  " Open test files.
  let s:test_files = [
    \ '10lines.txt',
    \ '30lines.txt',
    \ '50lines.txt',
  \ ]

  " Check if we're running from tests folder.

  " This check won't work correctly if we're in some other directory that has
  " a file named '1lines.txt' for some reason, but that won't happen on Travis.

  let s:test_file_to_check = s:test_files[0]
  if !filereadable(s:test_file_to_check)
    throw 'ERROR: required test file "'
      \ . s:test_file_to_check
      \ . '" not available in PWD!'
  endif

  let s:i = 0
  while s:i <# len(s:test_files)
    execute 'normal :edit! ' . s:test_files[s:i] . "\<cr>"
    let s:i += 1
  endwhile

################################################################################
# PopulateBufferDatabase, PopulateGlobalDatabase
################################################################################

Execute (Load Buffers, Set Local Marks, 50lines.txt):
  execute 'normal :edit! ' . '50lines.txt' . "\<cr>"
  execute  '5mark a'
  execute '15mark b'
  execute '25mark c'
  execute '35mark d'
  execute '45mark e'

  call markbar#state#PopulateBufferDatabase()
Then:
  let g:bufno_50lines = bufnr('%')
  let buffer_marks = g:buffersToMarks[g:bufno_50lines]
  AssertEqual ['a', '5', '0',  'fifth line'],           buffer_marks['a']
  AssertEqual ['b', '15', '0', 'fifteenth line'],       buffer_marks['b']
  AssertEqual ['c', '25', '0', 'twenty-fifth line'],    buffer_marks['c']
  AssertEqual ['d', '35', '0', 'thirty-fifth line'],    buffer_marks['d']
  AssertEqual ['e', '45', '0', 'forty-fifth line'],     buffer_marks['e']

Execute (Set Global Marks, 50lines.txt):
  " should still be on 50lines.txt, but just in case,
  execute 'normal! :e! #' . g:bufno_50lines . "\<cr>"
  execute '30mark C'
  execute '40mark D'
  execute '50mark E'
  call markbar#state#PopulateGlobalDatabase()
Then:
  " verify that local marks database was not affected
  let buffer_marks = g:buffersToMarks[g:bufno_50lines]
  AssertEqual ['a', '5', '0',  'fifth line'],           buffer_marks['a']
  AssertEqual ['b', '15', '0', 'fifteenth line'],       buffer_marks['b']
  AssertEqual ['c', '25', '0', 'twenty-fifth line'],    buffer_marks['c']
  AssertEqual ['d', '35', '0', 'thirty-fifth line'],    buffer_marks['d']
  AssertEqual ['e', '45', '0', 'forty-fifth line'],     buffer_marks['e']

  " check globals
  let buffer_marks = g:buffersToMarks[0]
  AssertEqual ['C', '30', '0', 'thirtieth line'],       buffer_marks['C']
  AssertEqual ['D', '40', '0', 'fortieth line'],        buffer_marks['D']
  AssertEqual ['E', '50', '0', 'fiftieth line'],        buffer_marks['E']

Execute (Set Global Marks, 30lines.txt):
  execute 'normal :edit! ' . '30lines.txt' . "\<cr>"
  let g:bufno_30lines = bufnr('%')
  execute '10mark A'
  execute '20mark B'

  execute  '1mark e'
  execute  '5mark d'
  execute '10mark c'
  execute '15mark b'
  execute '20mark a'

  call markbar#state#PopulateBufferDatabase()
  call markbar#state#PopulateGlobalDatabase()
Then:
  let buffer_marks = g:buffersToMarks[g:bufno_30lines]
  AssertEqual ['e', '1', '0',  'first line'],           buffer_marks['e']
  AssertEqual ['d', '5', '0',  'fifth line'],           buffer_marks['d']
  AssertEqual ['c', '10', '0', 'tenth line'],           buffer_marks['c']
  AssertEqual ['b', '15', '0', 'fifteenth line'],       buffer_marks['b']
  AssertEqual ['a', '20', '0', 'twentieth line'],       buffer_marks['a']

  " make sure that we didn't somehow overwrite these older ones
  let buffer_marks = g:buffersToMarks[g:bufno_50lines]
  AssertEqual ['a', '5', '0',  'fifth line'],           buffer_marks['a']
  AssertEqual ['b', '15', '0', 'fifteenth line'],       buffer_marks['b']
  AssertEqual ['c', '25', '0', 'twenty-fifth line'],    buffer_marks['c']
  AssertEqual ['d', '35', '0', 'thirty-fifth line'],    buffer_marks['d']
  AssertEqual ['e', '45', '0', 'forty-fifth line'],     buffer_marks['e']

  " NOTE: contents of 'file/text' aren't particularly meaningful here,
  "       maybe remove that field in the future? (TODO)
  let buffer_marks = g:buffersToMarks[0]
  AssertEqual ['A', '10', '0', 'tenth line'],           buffer_marks['A']
  AssertEqual ['B', '20', '0', 'twentieth line'],       buffer_marks['B']
  AssertEqual ['C', '30', '0', '50lines.txt'],          buffer_marks['C']
  AssertEqual ['D', '40', '0', '50lines.txt'],          buffer_marks['D']
  AssertEqual ['E', '50', '0', '50lines.txt'],          buffer_marks['E']

################################################################################
# UpdateContextsForBuffer tests
################################################################################

Execute (Update Local Contexts, 30lines.txt):
  execute 'normal :edit! ' . '30lines.txt' . "\<cr>"
  call markbar#state#UpdateContextsForBuffer(g:bufno_30lines, 3)
Then:
  " Only check 'indicator' values, for brevity. If these are fine, and if the
  " `test-fetchlines.vader` tests pass, assume that context fetching itself is
  " fine.
  let buffer_contexts = g:buffersToMarksToContexts[g:bufno_30lines]

  let expected = [
      \ 'nineteenth line',
      \ 'twentieth line',
      \ 'twenty-first line',
    \ ]
  AssertEqual expected, buffer_contexts['a']

  let expected = [
      \ 'first line',
      \ 'second line',
    \ ]
  AssertEqual expected, buffer_contexts['e']

Execute (Delete Mark, Update Local Contexts, 30lines.txt):
  execute 'normal :edit! ' . '30lines.txt' . "\<cr>"
  execute 'delmarks a'
  call markbar#state#PopulateBufferDatabase()
  call markbar#state#UpdateContextsForBuffer(g:bufno_30lines, 3)
Then:
  Assert !has_key(g:buffersToMarksToContexts[g:bufno_30lines], 'a')

Execute (Update Global Contexts, 30lines.txt):
  execute 'normal :edit! ' . '30lines.txt' . "\<cr>"
  call markbar#state#PopulateGlobalDatabase()
  call markbar#state#UpdateContextsForBuffer(0, 3)
Then:
  let buffer_contexts = g:buffersToMarksToContexts[0]
  let expected = [
      \ 'ninth line',
      \ 'tenth line',
      \ 'eleventh line',
    \ ]
  AssertEqual expected, buffer_contexts['A']

  let expected = [
      \ 'twenty-ninth line',
      \ 'thirtieth line',
      \ 'thirty-first line',
    \ ]
  AssertEqual expected, buffer_contexts['C']

  let expected = [
      \ 'forty-ninth line',
      \ 'fiftieth line',
    \ ]
  AssertEqual expected, buffer_contexts['E']

Execute (Update Global Contexts, Unloaded Buffer, 50lines.txt):
  execute 'bunload ' . g:bufno_50lines
  call remove(g:buffersToMarksToContexts, 0) " clear the existing global cache
  call markbar#state#UpdateContextsForBuffer(0, 3)
Then:
  let buffer_contexts = g:buffersToMarksToContexts[0]
  " even after unloading the buffer, the plugin should still be able to fetch
  " contexts from the files on disk
  let expected = [
      \ 'ninth line',
      \ 'tenth line',
      \ 'eleventh line',
    \ ]
  AssertEqual expected, buffer_contexts['A']

  let expected = [
      \ 'twenty-ninth line',
      \ 'thirtieth line',
      \ 'thirty-first line',
    \ ]
  AssertEqual expected, buffer_contexts['C']

  let expected = [
      \ 'forty-ninth line',
      \ 'fiftieth line',
    \ ]
  AssertEqual expected, buffer_contexts['E']

" Having issues with this one: UpdateContextsForBuffer doesn't pull the
" truncated context after 10lines.txt has been copied over 30lines.txt.
" Could be an issue with how I'm using Vader?
" Execute (FIXME: Externally Modify the File, Update Contexts, 30lines.txt):
"   if !&autoread
"     throw 'TEST PRECONDITION FAILURE: `set autoread` in the test .vimrc!'
"   endif
"   silent execute '!cp 30lines.txt 30lines.txt.temp'
"   silent execute '!cp 10lines.txt 30lines.txt'
"   checktime " trigger autoread

"   call markbar#state#PopulateGlobalDatabase()
"   call markbar#state#UpdateContextsForBuffer(0, 3)

" Then:
"   " make sure to clean up, even if the Execute block failed partway through
"   " silent! execute '!mv 30lines.txt.temp 30lines.txt'
"   let buffer_contexts = g:buffersToMarksToContexts[0]

"   let expected = [
"       \ 'ninth line',
"       \ 'tenth line',
"     \ ]
"   AssertEqual expected, buffer_contexts['A']
"   Assert !has_key(g:buffersToMarks, 'B')
